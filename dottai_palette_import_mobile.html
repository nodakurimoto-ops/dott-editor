<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒ‰ãƒƒãƒˆçµµã‚¨ãƒ‡ã‚£ã‚¿ Proï¼ˆãƒ‘ãƒ¬ãƒƒãƒˆç·¨é›†/ç”»åƒãƒ‘ãƒ¬ãƒƒãƒˆå¤‰æ›ï¼‰</title>
<style>
  :root{ --gap: 8px; --panel-bg:#f6f7f9; --border:#d0d7de; --accent:#2563eb; }
  body{ margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN","Yu Gothic", Meiryo, sans-serif; color:#111; background:#fff; }
  header{ padding:12px 16px; border-bottom:1px solid var(--border); background:#fff; position:sticky; top:0; z-index:10; }
  h1{ font-size:18px; margin:0; }
  main{ display:grid; grid-template-columns: 360px 1fr; gap: var(--gap); padding: var(--gap); }
  @media (max-width: 980px){ main{ grid-template-columns: 1fr; } }
  .panel{ background: var(--panel-bg); border:1px solid var(--border); border-radius:10px; padding:12px; }
  .row{ display:flex; align-items:center; gap:8px; margin-bottom:10px; flex-wrap:wrap; }
  label{ font-size:12px; color:#444; }
  input[type=number]{ width:92px; padding:6px 8px; border:1px solid var(--border); border-radius:6px; }
  input[type=text]{ width:100%; max-width: 420px; padding:6px 8px; border:1px solid var(--border); border-radius:6px; }
  input[type=color]{ width:44px; height:34px; padding:0; border:1px solid var(--border); border-radius:8px; background:#fff; }
  select{ padding:6px 8px; border:1px solid var(--border); border-radius:8px; background:#fff; }
  input[type=file]{ display:none; }
  button{ appearance:none; border:1px solid var(--border); background:#fff; padding:8px 12px; border-radius:8px; cursor:pointer; }
  button:hover{ border-color:#aaa; }
  button.primary{ background: var(--accent); color:#fff; border-color: var(--accent); }
  button.primary:hover{ filter:brightness(0.95); }
  button.tool.selected, .swatch.selected{ outline:3px solid rgba(37,99,235,0.45); outline-offset:1px; }
  .palette{ display:flex; flex-wrap:wrap; gap:8px; }
  .swatch{
    width:28px; height:28px; border-radius:6px; border:1px solid var(--border);
    cursor:pointer; position:relative; padding:0;
  }
  .swatch.transparent::before{
    content:""; position:absolute; inset:0;
    background-image: conic-gradient(#ddd 25%, #bbb 0 50%, #ddd 0 75%, #bbb 0);
    background-size: 8px 8px; border-radius:6px;
  }
  .swatch .del{
    position:absolute; top:-7px; right:-7px;
    width:16px; height:16px; border-radius:999px;
    background:#fff; border:1px solid var(--border);
    display:flex; align-items:center; justify-content:center;
    font-size:11px; line-height:1; color:#444;
  }
  .swatch .del:hover{ border-color:#999; }
  .tools{ display:flex; gap:8px; flex-wrap:wrap; }
  .canvas-wrap{ width: max-content; border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#fff; }
  #stage{
    display:block; image-rendering: pixelated;
    background-image: conic-gradient(#eee 25%, #ccc 0 50%, #eee 0 75%, #ccc 0);
    background-size: 16px 16px; touch-action: none;
  }
  .footer-row{ margin-top:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  small.hint{ color:#666; }
  .divider{ height:1px; background:var(--border); margin:12px 0; }
  .kbd{ font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        background:#f3f4f6; border:1px solid #e5e7eb; padding:2px 6px; border-radius:4px; }
  .pill{ font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid var(--border); background:#fff; }
  .warn{ color:#92400e; background:#fffbeb; border-color:#fde68a; }


/* ===== ãƒ¢ãƒã‚¤ãƒ«UIï¼ˆä¸‹éƒ¨ãƒãƒ¼ï¼‹ãƒ‘ãƒ¬ãƒƒãƒˆå¼•ãå‡ºã—ï¼‰ ===== */
.mobile-bar{ display:none; }
.drawer{ display:none; }

@media (max-width: 860px){
  main{
    grid-template-columns: 1fr;
    padding-bottom: 92px; /* ä¸‹éƒ¨ãƒãƒ¼åˆ†ã®ä½™ç™½ */
  }
  button{ min-height: 44px; }
  .swatch{ width:40px; height:40px; }
  .canvas-wrap{ margin:0 auto; }

  .mobile-bar{
    display:block;
    position: fixed;
    left:0; right:0; bottom:0;
    background:#fff;
    border-top:1px solid var(--border);
    z-index: 1000;
    padding:10px 10px calc(10px + env(safe-area-inset-bottom));
  }
  .mobile-row{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:space-between;
  }
  .mobile-row button{
    flex:1;
    font-weight:700;
    border-radius:14px;
  }
  .mobile-row .mini{
    flex:0 0 auto;
    min-width:44px;
  }

  .drawer{
    position: fixed;
    left:10px; right:10px;
    bottom: 92px;
    max-height: 60vh;
    background:#fff;
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow: 0 8px 24px rgba(0,0,0,.12);
    z-index: 999;
    display:none;
    overflow:auto;
  }
  .drawer.open{ display:block; }
  .drawer-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:10px 12px;
    border-bottom:1px solid var(--border);
    position: sticky;
    top: 0;
    background:#fff;
  }
  .drawer-body{ padding:12px; }
}

</style>
</head>
<body>
<header><h1>ãƒ‰ãƒƒãƒˆçµµã‚¨ãƒ‡ã‚£ã‚¿ Proï¼ˆãƒ‘ãƒ¬ãƒƒãƒˆç·¨é›†/ç”»åƒãƒ‘ãƒ¬ãƒƒãƒˆå¤‰æ›ï¼‰</h1></header>

<main>
  <section class="panel" id="controls">
    <h2 style="font-size:14px;margin:4px 0 10px;">è¨­å®š</h2>
    <div class="row">
      <label>æ¨ªãƒ‰ãƒƒãƒˆæ•°</label><input type="number" id="gridW" min="1" max="256" value="32" />
      <label>ç¸¦ãƒ‰ãƒƒãƒˆæ•°</label><input type="number" id="gridH" min="1" max="256" value="32" />
    </div>
    <div class="row">
      <label>è¡¨ç¤ºå€ç‡ï¼ˆã‚»ãƒ«ã‚µã‚¤ã‚º pxï¼‰</label>
      <input type="number" id="cellSize" min="4" max="64" step="1" value="16" />
      <button class="primary" id="apply" type="button">é©ç”¨</button>
      <button id="clear" type="button">ã‚¯ãƒªã‚¢</button>
    </div>

    <h2 style="font-size:14px;margin:12px 0 6px;">ãƒ„ãƒ¼ãƒ«</h2>
    <div class="tools">
      <button class="tool selected" id="toolPencil" title="B" type="button">é‰›ç­†</button>
      <button class="tool" id="toolEraser" title="E" type="button">æ¶ˆã—ã‚´ãƒ </button>
      <button class="tool" id="toolEyedropper" title="I" type="button">ã‚¹ãƒã‚¤ãƒˆ</button>
      <button class="tool" id="toolBucket" title="G" type="button">ãƒã‚±ãƒ„</button>
    </div>

    <div class="row">
      <button id="undoBtn" title="Ctrl+Z" type="button">ã‚¢ãƒ³ãƒ‰ã‚¥</button>
      <button id="redoBtn" title="Ctrl+Y / Ctrl+Shift+Z" type="button">ãƒªãƒ‰ã‚¥</button>
    </div>

    <div class="divider"></div>

    <h2 style="font-size:14px;margin:12px 0 6px;">ãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆé€éã‚ã‚Šï¼‰</h2>
    <div class="row" style="justify-content:space-between;">
      <div class="row" style="margin:0;">
        <label>è¿½åŠ </label>
        <input type="color" id="palettePicker" value="#ff0000" />
        <button id="addColorBtn" type="button">è‰²ã‚’è¿½åŠ </button>
        <button id="addCurrentBtn" type="button" title="ã‚¹ãƒã‚¤ãƒˆã§å–å¾—ã—ãŸè‰²ãªã©">ç¾åœ¨è‰²ã‚’è¿½åŠ </button>
      </div>
      <span id="paletteInfo" class="pill warn">è‰²æ•°: 16</span>
    </div>
    <div class="palette" id="palette"></div>
    <small class="hint">â€»å„è‰²ã®å³ä¸Šã€ŒÃ—ã€ã§å‰Šé™¤ã§ãã¾ã™ï¼ˆé€éã¯å‰Šé™¤ä¸å¯ï¼‰ã€‚</small>

    <div class="divider"></div>

    <h2 style="font-size:14px;margin:12px 0 6px;">PNGã®ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿</h2>
    <div class="row">
      <label>ä¿å­˜å€ç‡</label>
      <input type="number" id="exportScale" min="1" max="64" step="1" value="1" />
      <button class="primary" id="savePNG" type="button">PNGä¿å­˜</button>
    </div>

    <div class="row">
      <input type="file" id="fileInput" accept="image/png,image/*" />
      <button id="loadPNG" type="button">ç”»åƒèª­ã¿è¾¼ã¿</button>
      <label>å¤‰æ›</label>
      <select id="importMode">
        <option value="palette" selected>ãƒ‘ãƒ¬ãƒƒãƒˆå¤‰æ›ã—ã¦åæ˜ </option>
        <option value="raw">ãã®ã¾ã¾ç¸®å°ã—ã¦åæ˜ ï¼ˆå¤‰æ›ãªã—ï¼‰</option>
      </select>
    </div>
    <div class="row">
      <label>ãƒ‡ã‚£ã‚¶</label>
      <select id="ditherMode">
        <option value="none" selected>ãªã—</option>
        <option value="fs">Floyd-Steinberg</option>
      </select>
      <label>é€éã—ãã„å€¤</label>
      <input type="number" id="alphaThreshold" min="0" max="255" value="1" />
      <small class="hint">â€»Î±ãŒã“ã®å€¤æœªæº€ã¯é€æ˜æ‰±ã„</small>
    </div>
    <small class="hint">â€»ã‚­ãƒ£ãƒ³ãƒã‚¹ã¸ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã§ã‚‚èª­ã¿è¾¼ã¿å¯ï¼ˆç”»åƒâ†’ç¾åœ¨ã®ãƒ‰ãƒƒãƒˆæ•°ï¼‹ãƒ‘ãƒ¬ãƒƒãƒˆã¸å¤‰æ›ï¼‰ã€‚</small>

    <div class="divider"></div>

    <small class="hint">
      å³ãƒ‰ãƒ©ãƒƒã‚°ã§æ¶ˆã—ã‚´ãƒ ã€‚<span class="kbd">Ctrl+Z</span> ã§ã‚¢ãƒ³ãƒ‰ã‚¥ã€
      <span class="kbd">Ctrl+Y</span> or <span class="kbd">Ctrl+Shift+Z</span> ã§ãƒªãƒ‰ã‚¥ã€‚<br>
      ã‚­ãƒ¼: <span class="kbd">B</span>=é‰›ç­† <span class="kbd">E</span>=æ¶ˆã— <span class="kbd">I</span>=ã‚¹ãƒã‚¤ãƒˆ <span class="kbd">G</span>=ãƒã‚±ãƒ„
    </small>
  </section>

  <section>
    <div class="canvas-wrap">
      <canvas id="stage" width="512" height="512"></canvas>
    </div>
    <div class="footer-row">
      <small class="hint">ãƒ‰ãƒ©ãƒƒã‚°ã§é€£ç¶šæç”»ã€‚ç”»åƒèª­ã¿è¾¼ã¿ã¯ã€Œç¾åœ¨ã®ãƒ‰ãƒƒãƒˆæ•°ã€ã«ãƒªã‚µã‚¤ã‚ºå¾Œã€ï¼ˆé¸æŠæ™‚ï¼‰ãƒ‘ãƒ¬ãƒƒãƒˆã¸é‡å­åŒ–ã—ã¦åæ˜ ã—ã¾ã™ã€‚</small>
    </div>
  </section>
</main>



<!-- ===== ã‚¹ãƒãƒ›ç”¨ï¼šä¸‹éƒ¨ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ï¼ˆPCã§ã¯éè¡¨ç¤ºï¼‰ ===== -->
<div class="mobile-bar" id="mobileBar">
  <div class="mobile-row">
    <button class="mini" id="mbUndo" type="button" title="Undo">â†¶</button>
    <button id="mbPencil" type="button">é‰›ç­†</button>
    <button id="mbEraser" type="button">æ¶ˆã—</button>
    <button id="mbEye" type="button">ã‚¹ãƒ</button>
    <button id="mbBucket" type="button">å¡—</button>
    <button class="mini" id="mbPalette" type="button" title="Palette">ğŸ¨</button>
    <button class="mini" id="mbRedo" type="button" title="Redo">â†·</button>
  </div>
</div>

<!-- ===== ã‚¹ãƒãƒ›ç”¨ï¼šãƒ‘ãƒ¬ãƒƒãƒˆå¼•ãå‡ºã—ï¼ˆPCã§ã¯éè¡¨ç¤ºï¼‰ ===== -->
<div class="drawer" id="paletteDrawer" aria-hidden="true">
  <div class="drawer-header">
    <strong style="font-size:13px;">ãƒ‘ãƒ¬ãƒƒãƒˆ</strong>
    <button id="drawerClose" type="button">é–‰ã˜ã‚‹</button>
  </div>
  <div class="drawer-body">
    <div class="palette" id="drawerPalette"></div>

    <div class="divider"></div>

    <div class="row" style="margin-bottom:0;">
      <label>è¿½åŠ </label>
      <input type="color" id="drawerPicker" value="#ff0000" />
      <button id="drawerAdd" type="button">è¿½åŠ </button>
      <button id="drawerAddCurrent" type="button">ç¾åœ¨è‰²</button>
      <span id="drawerInfo" class="pill warn">è‰²æ•°: 16</span>
    </div>
  </div>
</div>

<script>
(()=>{
  // ===== åˆæœŸãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆ16è‰²ï¼‰ =====
  let paletteHex = [
    "#000000","#ffffff","#c0c0c0","#808080",
    "#ff0000","#00ff00","#0000ff","#ffff00",
    "#00ffff","#ff00ff","#8b4513","#ffa500",
    "#800000","#008080","#800080","#008000",
  ];
  const TRANSPARENT = "transparent";

  // ===== DOM =====
  const stage = document.getElementById("stage");
  const ctx = stage.getContext("2d");
  const gridWInput = document.getElementById("gridW");
  const gridHInput = document.getElementById("gridH");
  const cellSizeInput = document.getElementById("cellSize");
  const applyBtn = document.getElementById("apply");
  const clearBtn = document.getElementById("clear");
  const saveBtn = document.getElementById("savePNG");
  const exportScaleInput = document.getElementById("exportScale");
  const paletteBox = document.getElementById("palette");
  const palettePicker = document.getElementById("palettePicker");
  const addColorBtn = document.getElementById("addColorBtn");
  const addCurrentBtn = document.getElementById("addCurrentBtn");
  const paletteInfo = document.getElementById("paletteInfo");

  const toolPencil = document.getElementById("toolPencil");
  const toolEraser = document.getElementById("toolEraser");
  const toolEyedropper = document.getElementById("toolEyedropper");
  const toolBucket = document.getElementById("toolBucket");
  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");

  const fileInput = document.getElementById("fileInput");
  const loadBtn = document.getElementById("loadPNG");
  const importMode = document.getElementById("importMode");
  const ditherMode = document.getElementById("ditherMode");
  const alphaThresholdInput = document.getElementById("alphaThreshold");

  // ===== çŠ¶æ…‹ =====
  let gridW = parseInt(gridWInput.value, 10);
  let gridH = parseInt(gridHInput.value, 10);
  let cellSize = parseInt(cellSizeInput.value, 10);

  // pixels[y][x] = null(é€é) or [r,g,b,a]
  let pixels = createPixels(gridW, gridH);

  // å±¥æ­´
  let undoStack = [];
  let redoStack = [];
  const HISTORY_LIMIT = 100;
  let strokeStarted = false;

  // ãƒ„ãƒ¼ãƒ«
  let currentTool = "pencil";
  let currentColor = hexToRgba(paletteHex[0]);
  let lastPos = null;
  let isDrawing = false;

  // ===== åˆæœŸåŒ– =====
  buildPalette();
  setupCanvas();
  render();
  updatePaletteInfo();

  // ===== åŸºæœ¬ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  function createPixels(w,h){
    const arr = new Array(h);
    for(let y=0;y<h;y++) arr[y] = new Array(w).fill(null);
    return arr;
  }

  function deepCopyPixels(src){
    const h = src.length, w = src[0].length;
    const out = new Array(h);
    for(let y=0;y<h;y++){
      const row = src[y];
      const r = new Array(w);
      for(let x=0;x<w;x++) r[x] = row[x] ? row[x].slice() : null;
      out[y] = r;
    }
    return out;
  }

  function snapshot(){
    return { gridW, gridH, pixels: deepCopyPixels(pixels), paletteHex: paletteHex.slice() };
  }

  function restore(snap){
    gridW = snap.gridW; gridH = snap.gridH;
    gridWInput.value = gridW; gridHInput.value = gridH;
    paletteHex = snap.paletteHex.slice();
    pixels = deepCopyPixels(snap.pixels);

    // currentColor ãŒãƒ‘ãƒ¬ãƒƒãƒˆå¤–ãªã‚‰å…ˆé ­ã¸
    if (currentColor){
      const hex = rgbaToHex(currentColor);
      if (!paletteHex.includes(hex)) currentColor = hexToRgba(paletteHex[0]);
    }

    buildPalette();
    updatePaletteInfo();
    setupCanvas();
    render();
  }

  function pushHistory(){
    undoStack.push(snapshot());
    if (undoStack.length > HISTORY_LIMIT) undoStack.shift();
    redoStack = [];
  }

  function undo(){
    if (undoStack.length === 0) return;
    const cur = snapshot();
    const prev = undoStack.pop();
    redoStack.push(cur);
    restore(prev);
  }

  function redo(){
    if (redoStack.length === 0) return;
    const cur = snapshot();
    const next = redoStack.pop();
    undoStack.push(cur);
    restore(next);
  }

  function hexToRgba(hex){
    if (hex === TRANSPARENT || hex == null) return null;
    const v = hex.replace("#", "");
    const r = parseInt(v.slice(0,2),16);
    const g = parseInt(v.slice(2,4),16);
    const b = parseInt(v.slice(4,6),16);
    return [r,g,b,255];
  }

  function rgbaToHex(px){
    if (!px) return TRANSPARENT;
    const hh = (n)=> n.toString(16).padStart(2,"0");
    return `#${hh(px[0])}${hh(px[1])}${hh(px[2])}`;
  }

  function setupCanvas(){
    stage.width = gridW * cellSize;
    stage.height = gridH * cellSize;
    stage.style.backgroundSize = `${cellSize}px ${cellSize}px`;
    ctx.imageSmoothingEnabled = false;
  }

  function render(){
    ctx.clearRect(0,0,stage.width, stage.height);
    for(let y=0;y<gridH;y++){
      for(let x=0;x<gridW;x++){
        const px = pixels[y][x];
        if(px){
          const r=px[0], g=px[1], b=px[2], a=px[3];
          ctx.fillStyle = `rgba(${r},${g},${b},${a/255})`;
          ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
        }
      }
    }
    drawGridLines();
  }

  function drawGridLines(){
    const stroke = "rgba(0,0,0,0.06)";
    ctx.save();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let x=0;x<=gridW;x++){
      ctx.moveTo(x*cellSize+0.5, 0);
      ctx.lineTo(x*cellSize+0.5, gridH*cellSize);
    }
    for(let y=0;y<=gridH;y++){
      ctx.moveTo(0, y*cellSize+0.5);
      ctx.lineTo(gridW*cellSize, y*cellSize+0.5);
    }
    ctx.stroke();
    ctx.restore();
  }

  function canvasToGrid(clientX, clientY){
    const rect = stage.getBoundingClientRect();
    const x = Math.floor((clientX - rect.left) / cellSize);
    const y = Math.floor((clientY - rect.top) / cellSize);
    return {x,y};
  }
  function inBounds(x,y){ return x>=0 && y>=0 && x<gridW && y<gridH; }

  function drawLineOnGrid(x0,y0,x1,y1, plotter){
    let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    let err = dx + dy, e2;
    while(true){
      plotter(x0,y0);
      if(x0 === x1 && y0 === y1) break;
      e2 = 2 * err;
      if(e2 >= dy){ err += dy; x0 += sx; }
      if(e2 <= dx){ err += dx; y0 += sy; }
    }
  }

  // ===== ãƒ‘ãƒ¬ãƒƒãƒˆç·¨é›† =====
  function normalizeHex(hex){
    if (!hex) return null;
    let h = hex.trim().toLowerCase();
    if (!h.startsWith('#')) h = '#' + h;
    if (h.length === 4){
      // #rgb â†’ #rrggbb
      h = '#' + h[1]+h[1] + h[2]+h[2] + h[3]+h[3];
    }
    if (!/^#[0-9a-f]{6}$/.test(h)) return null;
    return h;
  }

  function updatePaletteInfo(){
    paletteInfo.textContent = `è‰²æ•°: ${paletteHex.length}`;
    paletteInfo.className = "pill" + (paletteHex.length !== 16 ? " warn" : "");
  }

  function buildPalette(){
    paletteBox.innerHTML = "";

    // é€éã‚¹ã‚¦ã‚©ãƒƒãƒ
    const transparentSw = document.createElement("button");
    transparentSw.className = "swatch transparent";
    transparentSw.title = "é€é";
    transparentSw.addEventListener("click", ()=>{
      selectSwatch(transparentSw);
      currentTool = "pencil"; selectToolButton(toolPencil);
      currentColor = null;
    });
    paletteBox.appendChild(transparentSw);

    // è‰²ã‚¹ã‚¦ã‚©ãƒƒãƒ
    paletteHex.forEach((hex)=>{
      const sw = document.createElement("button");
      sw.className = "swatch";
      sw.style.backgroundColor = hex;
      sw.title = hex;
      sw.addEventListener("click", ()=>{
        selectSwatch(sw);
        currentColor = hexToRgba(hex);
        currentTool = "pencil";
        selectToolButton(toolPencil);
      });

      const del = document.createElement("span");
      del.className = "del";
      del.textContent = "Ã—";
      del.title = "ã“ã®è‰²ã‚’å‰Šé™¤";
      del.addEventListener("click", (e)=>{
        e.stopPropagation();
        removeColor(hex);
      });
      sw.appendChild(del);

      paletteBox.appendChild(sw);
    });

    // åˆæœŸé¸æŠã‚’æ•´ãˆã‚‹
    syncPaletteSelectionToCurrentColor();
  }

  function selectSwatch(el){
    [...paletteBox.querySelectorAll(".swatch")].forEach(s => s.classList.remove("selected"));
    el.classList.add("selected");
  }

  function syncPaletteSelectionToCurrentColor(){
    const swatches = [...paletteBox.querySelectorAll(".swatch")];
    const hex = rgbaToHex(currentColor);
    let matched = false;
    for(const sw of swatches){
      if (sw.classList.contains("transparent") && hex === TRANSPARENT){ selectSwatch(sw); matched = true; break; }
      if (sw.title && sw.title.toLowerCase() === hex){ selectSwatch(sw); matched = true; break; }
    }
    if (!matched && swatches.length){
      // ãƒ‘ãƒ¬ãƒƒãƒˆå†…ã«ãªã„å ´åˆã€é¸æŠè¡¨ç¤ºã ã‘å¤–ã™
      swatches.forEach(s=>s.classList.remove("selected"));
    }
  }

  function removeColor(hex){
    if (paletteHex.length <= 1){
      alert("è‰²ã¯æœ€ä½1è‰²å¿…è¦ã§ã™ã€‚");
      return;
    }
    pushHistory();
    paletteHex = paletteHex.filter(h => h !== hex);

    // å‰Šé™¤ã—ãŸè‰²ã‚’ä½¿ã£ã¦ã„ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ã¯ã€æœ€ã‚‚è¿‘ã„æ®‹å­˜è‰²ã¸ç½®æ›
    const palRGBA = paletteHex.map(hexToRgba);
    for(let y=0;y<gridH;y++){
      for(let x=0;x<gridW;x++){
        const p = pixels[y][x];
        if (!p) continue;
        const pHex = rgbaToHex(p);
        if (pHex === hex){
          pixels[y][x] = nearestToPalette(p, palRGBA);
        }
      }
    }

    // currentColor ãŒå‰Šé™¤ã•ã‚ŒãŸã‚‰å…ˆé ­è‰²ã¸
    if (rgbaToHex(currentColor) === hex) currentColor = hexToRgba(paletteHex[0]);

    buildPalette();
    updatePaletteInfo();
    render();
  }

  function addColor(hex){
    const h = normalizeHex(hex);
    if (!h){ alert("ä¸æ­£ãªè‰²ã§ã™ã€‚"); return; }
    if (paletteHex.includes(h)) { alert("ã™ã§ã«ãƒ‘ãƒ¬ãƒƒãƒˆã«ã‚ã‚Šã¾ã™ã€‚"); return; }
    pushHistory();
    paletteHex.push(h);
    buildPalette();
    updatePaletteInfo();
  }

  // UI: è‰²è¿½åŠ 
  addColorBtn.addEventListener("click", ()=> addColor(palettePicker.value));
  addCurrentBtn.addEventListener("click", ()=>{
    if (!currentColor){
      alert("ç¾åœ¨è‰²ãŒé€éã§ã™ã€‚é€éã¯ãƒ‘ãƒ¬ãƒƒãƒˆã«è¿½åŠ ã§ãã¾ã›ã‚“ã€‚");
      return;
    }
    addColor(rgbaToHex(currentColor));
  });

  // ===== ãƒ„ãƒ¼ãƒ«é¸æŠ =====
  function selectToolButton(btn){
    [toolPencil, toolEraser, toolEyedropper, toolBucket].forEach(b=>b.classList.remove("selected"));
    btn.classList.add("selected");
  }
  toolPencil.addEventListener("click", ()=>{ currentTool="pencil"; selectToolButton(toolPencil); });
  toolEraser.addEventListener("click", ()=>{ currentTool="eraser"; selectToolButton(toolEraser); });
  toolEyedropper.addEventListener("click", ()=>{ currentTool="eyedropper"; selectToolButton(toolEyedropper); });
  toolBucket.addEventListener("click", ()=>{ currentTool="bucket"; selectToolButton(toolBucket); });

  // ===== è¨­å®š/ã‚¯ãƒªã‚¢ =====
  applyBtn.addEventListener("click", ()=>{
    const newW = clamp(parseInt(gridWInput.value,10)||32, 1, 256);
    const newH = clamp(parseInt(gridHInput.value,10)||32, 1, 256);
    const newCell = clamp(parseInt(cellSizeInput.value,10)||16, 4, 64);
    gridWInput.value = newW; gridHInput.value = newH; cellSizeInput.value = newCell;
    pushHistory();
    gridW = newW; gridH = newH; cellSize = newCell;
    pixels = createPixels(gridW, gridH);
    setupCanvas();
    render();
  });

  clearBtn.addEventListener("click", ()=>{
    pushHistory();
    pixels = createPixels(gridW, gridH);
    render();
  });

  // ===== æç”» =====
  stage.addEventListener("mousedown", (e)=>{
    e.preventDefault();
    const isRight = (e.button === 2);

    if (currentTool === "eyedropper"){
      const pos = canvasToGrid(e.clientX, e.clientY);
      if (inBounds(pos.x,pos.y)){
        const p = pixels[pos.y][pos.x];
        currentColor = p ? p.slice() : null;
        currentTool = "pencil";
        selectToolButton(toolPencil);
        syncPaletteSelectionToCurrentColor();
      }
      return;
    }

    if (currentTool === "bucket"){
      const pos = canvasToGrid(e.clientX, e.clientY);
      if (inBounds(pos.x,pos.y)){
        pushHistory();
        const fill = (isRight || currentTool === "eraser") ? null : currentColor;
        floodFill(pos.x, pos.y, fill);
        render();
      }
      return;
    }

    isDrawing = true;
    strokeStarted = false;
    lastPos = { x: e.clientX, y: e.clientY };
    paintAtEvent(e, isRight);
  });

  window.addEventListener("mousemove", (e)=>{
    if (!isDrawing) return;
    e.preventDefault();
    const isRight = (e.buttons === 2);

    const rect = stage.getBoundingClientRect();
    const fromX = Math.floor((lastPos.x - rect.left) / cellSize);
    const fromY = Math.floor((lastPos.y - rect.top) / cellSize);
    const toX   = Math.floor((e.clientX - rect.left) / cellSize);
    const toY   = Math.floor((e.clientY - rect.top) / cellSize);

    if (!strokeStarted){ pushHistory(); strokeStarted = true; }

    const isErase = (currentTool === "eraser") || isRight;
    const color = isErase ? null : currentColor;

    drawLineOnGrid(fromX, fromY, toX, toY, (x,y)=>{
      if (!inBounds(x,y)) return;
      pixels[y][x] = color ? color.slice() : null;
    });

    lastPos = { x: e.clientX, y: e.clientY };
    render();
  });

  window.addEventListener("mouseup", ()=>{ isDrawing = false; lastPos = null; strokeStarted = false; });
  stage.addEventListener("contextmenu", (e)=> e.preventDefault());

  function paintAtEvent(e, isRight){
    const pos = canvasToGrid(e.clientX, e.clientY);
    if (!inBounds(pos.x,pos.y)) return;
    if (!strokeStarted){ pushHistory(); strokeStarted = true; }

    const isErase = (currentTool === "eraser") || isRight;
    const color = isErase ? null : currentColor;
    pixels[pos.y][pos.x] = color ? color.slice() : null;
    render();
  }

  function equalPx(a,b){
    if (a === b) return true;
    if (!a || !b) return false;
    return a[0]===b[0] && a[1]===b[1] && a[2]===b[2] && a[3]===b[3];
  }

  function floodFill(sx, sy, newPx){
    const target = pixels[sy][sx];
    if (equalPx(target, newPx)) return;

    const stack = [[sx,sy]];
    const visited = new Uint8Array(gridW*gridH);

    while(stack.length){
      const p = stack.pop();
      const x = p[0], y = p[1];
      const idx = y*gridW + x;
      if (visited[idx]) continue;
      visited[idx] = 1;

      if (!inBounds(x,y)) continue;
      if (!equalPx(pixels[y][x], target)) continue;

      pixels[y][x] = newPx ? newPx.slice() : null;

      if (x>0) stack.push([x-1,y]);
      if (x<gridW-1) stack.push([x+1,y]);
      if (y>0) stack.push([x,y-1]);
      if (y<gridH-1) stack.push([x,y+1]);
    }
  }

  // ===== PNGä¿å­˜ =====
  saveBtn.addEventListener("click", ()=>{
    const scale = clamp(parseInt(exportScaleInput.value,10)||1, 1, 64);
    exportScaleInput.value = scale;

    const out = document.createElement("canvas");
    out.width = gridW * scale;
    out.height = gridH * scale;
    const octx = out.getContext("2d");
    octx.imageSmoothingEnabled = false;

    for(let y=0;y<gridH;y++){
      for(let x=0;x<gridW;x++){
        const p = pixels[y][x];
        if (!p) continue;
        octx.fillStyle = `rgba(${p[0]},${p[1]},${p[2]},${p[3]/255})`;
        octx.fillRect(x*scale, y*scale, scale, scale);
      }
    }

    const url = out.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = url;
    a.download = `pixel_${gridW}x${gridH}_x${scale}.png`;
    document.body.appendChild(a);
    a.click();
    requestAnimationFrame(()=>a.remove());
  });

  // ===== ç”»åƒèª­ã¿è¾¼ã¿ï¼ˆç¸®å° + ãƒ‘ãƒ¬ãƒƒãƒˆå¤‰æ›ï¼‰ =====
  loadBtn.addEventListener("click", ()=> fileInput.click());

  fileInput.addEventListener("change", ()=>{
    const file = fileInput.files && fileInput.files[0];
    if (file) importImageFile(file);
    fileInput.value = "";
  });

  // D&D
  stage.addEventListener("dragover", (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect = "copy"; });
  stage.addEventListener("drop", (e)=>{
    e.preventDefault();
    const file = e.dataTransfer.files && e.dataTransfer.files[0];
    if (file) importImageFile(file);
  });

  async function importImageFile(file){
    const mode = importMode.value; // palette / raw
    const dith = ditherMode.value; // none / fs
    const alphaTh = clamp(parseInt(alphaThresholdInput.value,10)||0, 0, 255);

    const reader = new FileReader();
    reader.onload = (ev)=>{
      const img = new Image();
      img.onload = ()=>{
        pushHistory();

        const off = document.createElement("canvas");
        off.width = gridW;
        off.height = gridH;
        const octx = off.getContext("2d", { willReadFrequently: true });
        octx.imageSmoothingEnabled = true; // é€šå¸¸ç”»åƒâ†’ç¸®å°ãªã®ã§ true ã®æ–¹ãŒç¶ºéº—
        octx.clearRect(0,0,gridW,gridH);
        octx.drawImage(img, 0, 0, gridW, gridH);

        const imgData = octx.getImageData(0,0,gridW,gridH);

        if (mode === "raw"){
          // raw: ãã®ã¾ã¾ (é€æ˜ã®ã¿åˆ¤å®š)
          for(let y=0;y<gridH;y++){
            for(let x=0;x<gridW;x++){
              const i = (y*gridW + x)*4;
              const r = imgData.data[i], g = imgData.data[i+1], b = imgData.data[i+2], a = imgData.data[i+3];
              pixels[y][x] = (a < alphaTh) ? null : [r,g,b,a];
            }
          }
          render();
          return;
        }

        // palette: ãƒ‘ãƒ¬ãƒƒãƒˆã¸é‡å­åŒ–ï¼ˆä»»æ„ã§ãƒ‡ã‚£ã‚¶ï¼‰
        const palRGBA = paletteHex.map(hexToRgba);

        if (dith === "fs"){
          pixels = quantizeWithFloydSteinberg(imgData, gridW, gridH, palRGBA, alphaTh);
        }else{
          pixels = quantizeNoDither(imgData, gridW, gridH, palRGBA, alphaTh);
        }

        render();
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  }

  function nearestToPalette(rgba, palRGBA){
    if (!rgba) return null;
    let br=rgba[0], bg=rgba[1], bb=rgba[2];
    let best=0, bestD=1e18;
    for(let i=0;i<palRGBA.length;i++){
      const p = palRGBA[i];
      const dr=br-p[0], dg=bg-p[1], db=bb-p[2];
      const d = dr*dr + dg*dg + db*db;
      if (d < bestD){ bestD = d; best = i; }
    }
    return palRGBA[best].slice();
  }

  function quantizeNoDither(imgData, w, h, palRGBA, alphaTh){
    const out = createPixels(w,h);
    const d = imgData.data;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = (y*w + x)*4;
        const a = d[i+3];
        if (a < alphaTh){ out[y][x] = null; continue; }
        const rgba = [d[i], d[i+1], d[i+2], 255];
        out[y][x] = nearestToPalette(rgba, palRGBA);
      }
    }
    return out;
  }

  // Floyd-Steinberg error diffusion dithering
  function quantizeWithFloydSteinberg(imgData, w, h, palRGBA, alphaTh){
    const out = createPixels(w,h);

    // ä½œæ¥­ç”¨ã« float ãƒãƒƒãƒ•ã‚¡ã‚’ä½œã‚‹
    const buf = new Float32Array(w*h*4);
    for(let i=0;i<buf.length;i++) buf[i] = imgData.data[i];

    const idxAt = (x,y)=> (y*w + x)*4;

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = idxAt(x,y);
        const a = buf[i+3];
        if (a < alphaTh){
          out[y][x] = null;
          // é€æ˜ã¯èª¤å·®æ‹¡æ•£ã—ãªã„
          continue;
        }

        const oldR = buf[i], oldG = buf[i+1], oldB = buf[i+2];
        const nearest = nearestToPalette([oldR, oldG, oldB, 255], palRGBA);
        out[y][x] = nearest;

        const errR = oldR - nearest[0];
        const errG = oldG - nearest[1];
        const errB = oldB - nearest[2];

        // distribute errors
        // (x+1,y)   7/16
        // (x-1,y+1) 3/16
        // (x,y+1)   5/16
        // (x+1,y+1) 1/16
        distribute(x+1,y,   7/16, errR, errG, errB);
        distribute(x-1,y+1, 3/16, errR, errG, errB);
        distribute(x,  y+1, 5/16, errR, errG, errB);
        distribute(x+1,y+1, 1/16, errR, errG, errB);
      }
    }

    function distribute(x,y,f,er,eg,eb){
      if (x<0 || y<0 || x>=w || y>=h) return;
      const j = idxAt(x,y);
      // é€æ˜ã¯è§¦ã‚‰ãªã„æ–¹ãŒè‡ªç„¶ãªã®ã§ã€Î±ãŒå°ã•ã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      if (buf[j+3] < alphaTh) return;
      buf[j]   = clamp(buf[j]   + er*f, 0, 255);
      buf[j+1] = clamp(buf[j+1] + eg*f, 0, 255);
      buf[j+2] = clamp(buf[j+2] + eb*f, 0, 255);
    }

    return out;
  }

  // ===== ã‚­ãƒ¼æ“ä½œ =====
  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if (k === "b"){ currentTool="pencil"; selectToolButton(toolPencil); }
    if (k === "e"){ currentTool="eraser"; selectToolButton(toolEraser); }
    if (k === "i"){ currentTool="eyedropper"; selectToolButton(toolEyedropper); }
    if (k === "g"){ currentTool="bucket"; selectToolButton(toolBucket); }

    if (e.ctrlKey && !e.shiftKey && k === "z"){ e.preventDefault(); undo(); }
    if ((e.ctrlKey && k === "y") || (e.ctrlKey && e.shiftKey && k === "z")){
      e.preventDefault(); redo();
    }
  });



  // ===== ãƒ¢ãƒã‚¤ãƒ«UIï¼ˆä¸‹éƒ¨ãƒãƒ¼ï¼‹ãƒ‘ãƒ¬ãƒƒãƒˆå¼•ãå‡ºã—ï¼‰é€£æº =====
  const mobileBar = document.getElementById('mobileBar');
  const mbUndo = document.getElementById('mbUndo');
  const mbRedo = document.getElementById('mbRedo');
  const mbPencil = document.getElementById('mbPencil');
  const mbEraser = document.getElementById('mbEraser');
  const mbEye = document.getElementById('mbEye');
  const mbBucket = document.getElementById('mbBucket');
  const mbPalette = document.getElementById('mbPalette');

  const paletteDrawer = document.getElementById('paletteDrawer');
  const drawerClose = document.getElementById('drawerClose');
  const drawerPalette = document.getElementById('drawerPalette');
  const drawerPicker = document.getElementById('drawerPicker');
  const drawerAdd = document.getElementById('drawerAdd');
  const drawerAddCurrent = document.getElementById('drawerAddCurrent');
  const drawerInfo = document.getElementById('drawerInfo');

  function isMobileUI(){
    return window.matchMedia && window.matchMedia('(max-width: 860px)').matches;
  }

  function syncMobileUI(){
    // è¡¨ç¤ºè‡ªä½“ã¯CSSãŒæ‹…å½“ã€‚ã“ã“ã§ã¯å¼•ãå‡ºã—ã®çŠ¶æ…‹ã ã‘æ•´ãˆã‚‹ã€‚
    if (!isMobileUI()) closeDrawer();
    // ãƒ„ãƒ¼ãƒ«é¸æŠã®åŒæœŸ
    updateMobileToolSelection();
  }

  window.addEventListener('resize', syncMobileUI);
  syncMobileUI();

  function updateMobileToolSelection(){
    if (!mbPencil) return;
    [mbPencil, mbEraser, mbEye, mbBucket].forEach(b=>b.classList.remove('selected'));
    if (currentTool === 'pencil') mbPencil.classList.add('selected');
    if (currentTool === 'eraser') mbEraser.classList.add('selected');
    if (currentTool === 'eyedropper') mbEye.classList.add('selected');
    if (currentTool === 'bucket') mbBucket.classList.add('selected');
  }

  function setTool(tool){
    currentTool = tool;
    // PCå´ã®è¡¨ç¤ºã‚‚åŒæœŸ
    if (tool === 'pencil') selectToolButton(toolPencil);
    if (tool === 'eraser') selectToolButton(toolEraser);
    if (tool === 'eyedropper') selectToolButton(toolEyedropper);
    if (tool === 'bucket') selectToolButton(toolBucket);
    updateMobileToolSelection();
  }

  // ä¸‹éƒ¨ãƒãƒ¼æ“ä½œ
  if (mbPencil){
    mbPencil.addEventListener('click', ()=> setTool('pencil'));
    mbEraser.addEventListener('click', ()=> setTool('eraser'));
    mbEye.addEventListener('click', ()=> setTool('eyedropper'));
    mbBucket.addEventListener('click', ()=> setTool('bucket'));
    mbUndo.addEventListener('click', ()=> undo());
    mbRedo.addEventListener('click', ()=> redo());
    mbPalette.addEventListener('click', ()=> toggleDrawer());
  }

  function openDrawer(){
    if (!paletteDrawer) return;
    paletteDrawer.classList.add('open');
    paletteDrawer.setAttribute('aria-hidden','false');
    rebuildDrawerPalette();
  }
  function closeDrawer(){
    if (!paletteDrawer) return;
    paletteDrawer.classList.remove('open');
    paletteDrawer.setAttribute('aria-hidden','true');
  }
  function toggleDrawer(){
    if (!paletteDrawer) return;
    if (paletteDrawer.classList.contains('open')) closeDrawer();
    else openDrawer();
  }
  if (drawerClose) drawerClose.addEventListener('click', closeDrawer);

  function rebuildDrawerPalette(){
    if (!drawerPalette) return;
    drawerPalette.innerHTML = '';
    if (drawerInfo) drawerInfo.textContent = `è‰²æ•°: ${paletteHex.length}`;

    // é€é
    const t = document.createElement('button');
    t.className = 'swatch transparent';
    t.title = 'é€é';
    t.addEventListener('click', ()=>{
      currentColor = null;
      setTool('pencil');
      markDrawerSelection(TRANSPARENT);
    });
    drawerPalette.appendChild(t);

    // è‰²
    paletteHex.forEach((hex)=>{
      const sw = document.createElement('button');
      sw.className = 'swatch';
      sw.style.backgroundColor = hex;
      sw.title = hex;
      sw.addEventListener('click', ()=>{
        currentColor = hexToRgba(hex);
        setTool('pencil');
        markDrawerSelection(hex);
      });

      const del = document.createElement('span');
      del.className = 'del';
      del.textContent = 'Ã—';
      del.title = 'ã“ã®è‰²ã‚’å‰Šé™¤';
      del.addEventListener('click', (e)=>{
        e.stopPropagation();
        removeColor(hex);
        rebuildDrawerPalette();
      });
      sw.appendChild(del);

      drawerPalette.appendChild(sw);
    });

    // ç¾åœ¨è‰²ã®é¸æŠè¡¨ç¤º
    const curHex = rgbaToHex(currentColor);
    markDrawerSelection(curHex);
  }

  function markDrawerSelection(hex){
    if (!drawerPalette) return;
    [...drawerPalette.querySelectorAll('.swatch')].forEach(s=>s.classList.remove('selected'));
    // transparent
    if (hex === TRANSPARENT){
      const t = drawerPalette.querySelector('.swatch.transparent');
      if (t) t.classList.add('selected');
      return;
    }
    // colors
    const target = [...drawerPalette.querySelectorAll('.swatch')].find(s=>s.title && s.title.toLowerCase() === (hex||'').toLowerCase());
    if (target) target.classList.add('selected');
  }

  // Drawer: add color
  if (drawerAdd){
    drawerAdd.addEventListener('click', ()=>{
      addColor(drawerPicker.value);
      rebuildDrawerPalette();
    });
  }
  if (drawerAddCurrent){
    drawerAddCurrent.addEventListener('click', ()=>{
      if (!currentColor){
        alert('ç¾åœ¨è‰²ãŒé€éã§ã™ã€‚é€éã¯ãƒ‘ãƒ¬ãƒƒãƒˆã«è¿½åŠ ã§ãã¾ã›ã‚“ã€‚');
        return;
      }
      addColor(rgbaToHex(currentColor));
      rebuildDrawerPalette();
    });
  }

  // buildPalette / updatePaletteInfo / selectToolButton ã‚’ãƒ©ãƒƒãƒ—ã—ã¦ãƒ¢ãƒã‚¤ãƒ«UIã‚‚åŒæœŸ
  const _origBuildPalette = buildPalette;
  buildPalette = function(){
    _origBuildPalette();
    rebuildDrawerPalette();
  };
  const _origUpdatePaletteInfo = updatePaletteInfo;
  updatePaletteInfo = function(){
    _origUpdatePaletteInfo();
    if (drawerInfo) drawerInfo.textContent = `è‰²æ•°: ${paletteHex.length}`;
  };
  const _origSelectToolButton = selectToolButton;
  selectToolButton = function(btn){
    _origSelectToolButton(btn);
    updateMobileToolSelection();
  };

  // åˆå›åŒæœŸ
  rebuildDrawerPalette();
  updateMobileToolSelection();

})();
</script>
</body>
</html>
